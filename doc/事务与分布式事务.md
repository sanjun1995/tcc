# TCC分布式事务

### 一、事务

#### 1、什么事务

数据库事务指一个逻辑工作单元，由一些列操作组成，这些操作要么完全执行，要么完全不执行。因此事务必须满足所谓的ACID特性（原子性、一致性、隔离性和持久性）

##### （1）原子性（Atomicity）

指事务包含的所有操作要么全部成功，要么全部失败回滚。

##### （2）一致性（Consistency）

指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

##### （3）隔离型（Isolation）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

##### （4）持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

#### 2、事务并发

当多个事务同时访问数据库中相同数据时，如果没有采取必要的隔离机制，就会导致各种并发问题。归纳如下：

1、脏读（dirty read）：一个事务读取了另一个事务尚未提交的数据。

2、幻读（phantom read）：一个事务的操作导致另一个事务前后两次读取到不同的数据。 

3、不可重复读(no-repeatable read)：一个事务的操作导致另一个事务前后两次读取到不同的数据。

第一类丢失更新：撤销一个事务时，把其他事务已提交的更新数据覆盖。

第二类丢失更新：是不可重复读的特殊情况。如果两个事物都读取同一行，然后两个都进行写操作，并提交，第一个事物所做的改变就会丢失。

#### 3、事务隔离级别

•Serializable(串行化)：一个事务在执行过程中完全看不到其他事务对数据库所做的更新。 
•Repeatable Read(可重复读)：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。 
•Read Commited（读已提交数据）：一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且能看到其他事务已经提交的对已有记录的更新 

•Read Uncomitted（读未提交数据）：一个事务在执行过程中可以拷打其他事务没有提交的新插入的记录，而且能看到其他事务没有提交的对已有记录的更新。



### 二、分布式事务

随着互联网带来的海量数据规模，单一的集中的IT架构无法满足计算和存储的需求，进行垂直分割和水平分割，把大的单体应用转型为微服务，虽则服务模块化拆分，同时还有数据库的垂直拆分，根据业务系统功能，将数据库拆分为多个，每个系统使用独立的数据库。数据拆分后，解决了单机存储容量和性能问题，但也带来了数据一致性问题。如何保证跨库，跨应用业务操作的原子性。

#### 1、解决分布式事务，主要两大途径：

- 1.利用数据资源层的特性进行两阶段操作，第一阶段Prepare期间一直持有锁，ready后，执行提交或者回滚。由于整个事务期间占用数据库连接，并锁定数据，导致并发度低。不适合互联网应用。

- 2.兼顾并发处理，目前业界主流做法是在服务层进行补偿。适当降低一致性，达到BASE理论要求的，“基本可用，最终一致”。BASE 理论是指BA（Basic Availability，基本业务可用性）；S（Soft state，柔性状态）；E（Eventual consistency，最终一致性）。



  在并发处理方面，由于TCC模型相对于XA模型进一步减少了资源锁的持有时间，TCC模型中，Try阶段就提交事务，从而释放锁定的资源；而不是像XA那样整个Prepare阶段一直持有锁。因此TCC比XA模型具有较大的性能提升。

  从理论上讲，只要Try阶段完成，Confirm/Cancel阶段什么时候执行都可以，因为资源已经被锁定，不会被其他事务使用；这就给异步执行提供了可能，在业务并发高峰时期，可以使用框架内部的事件队列来处理二阶段操作。


#### 2、基于业务补偿的TCC事务模型：

TCC实际上，就是把数据资源层的两阶段提交上提到了应用层来实现。本质上，TCC也是两阶段完成事务执行，追求数据的最终一致性，而不是实时一致性。TCC缺点主要是有一定的开发成本：因为Try，Confirm和Cancel操作功能需要业务提供。

TCC事务的核心概念如下

- **发起者主事务**：
  - 作为tcc事务发起者，负责发起并管理包括所有参与者的整个业务活动。
  - 捕获到异常，调用所有参与者的cancel方法
  - 正常结束后，调用所有参与者的confirm方法
- **参与者从事务**：
  - 负责提供tcc业务操作，是整个业务活动的参与方。
  - 必须实现Try，Confirm，Cancel三个方法供事务发起者调用。
- **事务管理器**：
  - 每个TCC事务的发起方，参与方都各自维护各自的TCC事务，封装参与者调用点，并持久化到存储设备上。
  - 每个服务内置的TCC事务管理器负责，对自身的所有参与者执行确认或取消操作。
  - 每个TCC事务根据参与者的执行状态进行失败重试。
  - 内置的TCC事务根据当前执行状态判断是否重新执行确认或者取消操作，保证每个confirm或者cancel能且只能执行一次。
- **TRY操作**：
  - 完成业务检查，预留必须的业务资源。
- **Confirm确认操作**：
  - 真正执行业务逻辑，不需要做任何业务检查，只Try阶段预留的业务资源。
  - Confirm操作需要满足幂等性。
- **Cancel取消操作：**
  - 释放Try阶段预留的业务资源。
  - 同样，Cancel操作需要满足幂等性。

在进行TCC框架设计时，考虑到从业务层面保证幂等性往往代价很大；我在TCC事务管理器根据状态机来保证Confirm能且仅被执行一次。

![](/Users/xuyi/professional/java/workspace/spring-dtx/tcc/doc/tcc.png)



























### 参考资料

《大规模SOA系统中的分布式事务处理》：蚂蚁金服CTO程立早年的一篇关于分布式事务的PPT，里面有关于大规模SOA系统中包括TCC在内的各种分布式事务处理方案，是支付宝在分布式事务实践的经验精华。

《Atomic Distributed Transactions: a RESTful Design》：ATOMIKOS公司的Guy Pardon和另一位作者一同写的一篇关于TCC事务设计方案的论文，对TCC的实现细节描述较为清楚